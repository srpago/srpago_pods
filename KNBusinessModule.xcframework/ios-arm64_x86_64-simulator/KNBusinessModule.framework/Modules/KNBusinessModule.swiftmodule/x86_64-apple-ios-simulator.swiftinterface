// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name KNBusinessModule
// swift-module-flags-ignorable: -enable-bare-slash-regex
import CoreTelephony
import Foundation
import KNAnalyticsPaymentModule
@_exported import KNBusinessModule
import KNCore
import Swift
import SystemConfiguration
import UIKit
import _Concurrency
import _StringProcessing
public typealias KNMakePayment = (response: KNCore.KNMakePaymentResult?, error: KNBusinessModule.TransactionError?)
public struct TransactionError : Swift.Codable {
  public let code: Swift.String?
  public let description: Swift.String
  public let message: Swift.String
  public let detail: KNBusinessModule.KNErrorDetail?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNErrorDetail : Swift.Codable {
  public let code: Swift.String
  public let httpStatusCode: Swift.Int
  public let message: Swift.String
  public let issuerAuthenticationData: Swift.String?
  public let tag8a: Swift.String?
  public let issuerScriptData: Swift.String?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum KNNetworkError : Swift.String, Swift.Error {
  case encodingFailed
  case missingURL
  case authenticationError
  case badRequest
  case paymentRequestTimeout
  case outdated
  case failed
  case noData
  case unableToDecode
  case noNetworkAvailable
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct KNAppLoginUseCase {
  public init()
  public func invoke(appKey: Swift.String, result: @escaping (KNBusinessModule.KNAuth?) -> Swift.Void)
}
public struct KNMakeReversalUseCase {
  public init()
  public func invoke(transactionID: Swift.String, reversalType: KNCore.ReversalType, result: @escaping (KNBusinessModule.KNReversal?) -> Swift.Void)
}
public typealias KNPaymentSettings = (response: KNBusinessModule.KNPaymentSettingsResult?, error: Swift.Error?)
public struct KNPaymentSettingsResult : Swift.Codable {
  public let monthlyInstallments: KNBusinessModule.KNMonthlyInstallments
  public let paymentMethods: KNBusinessModule.KNPaymmentMethods
  public let tip: KNBusinessModule.KNTipSettings
  public let reference: KNBusinessModule.KNReferenceSettings
  public var isCertification: Swift.Bool?
  public var contactless: [KNBusinessModule.KNContactless]?
  public var trackingReader: KNBusinessModule.KNTrackingReader?
  public var currentDate: Swift.String?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNMonthlyInstallments : Swift.Codable {
  public let enabled: Swift.Bool
  public let minAmount: Swift.String
  public let available: [Swift.String]
  public let selected: [Swift.String]?
  public let selectedAmount: Swift.String?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNPaymmentMethods : Swift.Codable {
  public let swipe: Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNTipSettings : Swift.Codable {
  public let enabled: Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNReferenceSettings : Swift.Codable {
  public let available: [Swift.String]
  public let selected: Swift.String?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNContactless : Swift.Codable {
  public let active: Swift.Bool
  public let device: Swift.String
  public let lastFirmwareVersion: Swift.String?
  public let urlDownloadFirmware: Swift.String?
  public let lastConfigVersion: Swift.String?
  public let urlDownloadConfig: Swift.String?
  public let forceUpdate: Swift.Bool?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct KNTrackingReader : Swift.Codable {
  public let log: Swift.Bool
  public let isRefund: Swift.Bool
  public init(log: Swift.Bool, isRefund: Swift.Bool)
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNAccountInfoUseCase {
  public init()
  public func invoke(result: @escaping (KNBusinessModule.KNAccountInfo?) -> Swift.Void)
}
@_hasMissingDesignatedInitializers public class ConnectionType {
  public static func getConnectionType() -> Swift.String
  @objc deinit
}
public struct KNPartialPromortionUseCase {
  public init()
  public func invoke(binCardNumber: Swift.String, amount: Swift.Float, result: @escaping (KNBusinessModule.KNPartialPromotion?) -> Swift.Void)
}
public struct KNSendOperationSMSUseCase {
  public init()
  public func invoke(sms: Swift.String, operationId: Swift.String, result: @escaping (KNBusinessModule.KNSendRecipe?) -> Swift.Void)
}
public typealias KNAccountInfo = (response: KNBusinessModule.KNAccountInfoResult?, error: Swift.Error?)
public struct KNAccountInfoDomain : Swift.Codable {
  public let success: Swift.Bool
  public let message: Swift.String?
  public let error: KNBusinessModule.KNAuthError?
  public let result: KNBusinessModule.KNAccountInfoResult?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNAccountInfoResult : Swift.Codable {
  public let id: Swift.Int
  public let firstName: Swift.String
  public let lastName: Swift.String?
  public let surname: Swift.String?
  public let email: Swift.String
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNOperator : Swift.Codable {
  public let id: Swift.Int
  public let isOperator: Swift.Bool
  public let email: Swift.String?
  public let name: Swift.String?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum ReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let reachabilityChangedNotification: Foundation.NSNotification.Name
extension Foundation.NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class Reachability {
  public typealias NetworkReachable = (KNBusinessModule.Reachability) -> Swift.Void
  public typealias NetworkUnreachable = (KNBusinessModule.Reachability) -> Swift.Void
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: KNBusinessModule.Reachability.NetworkStatus, b: KNBusinessModule.Reachability.NetworkStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Connection : Swift.CustomStringConvertible {
    case unavailable, wifi, cellular
    public var description: Swift.String {
      get
    }
    @available(*, deprecated, renamed: "unavailable")
    public static let none: KNBusinessModule.Reachability.Connection
    public static func == (a: KNBusinessModule.Reachability.Connection, b: KNBusinessModule.Reachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: KNBusinessModule.Reachability.NetworkReachable?
  public var whenUnreachable: KNBusinessModule.Reachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: KNBusinessModule.Reachability.Connection {
    get
  }
  public var connection: KNBusinessModule.Reachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  convenience public init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  convenience public init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
}
extension KNBusinessModule.Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
public struct KNPrinterUseCase {
  public func invoke(token: Swift.String)
}
public struct KNMakePaymentUseCase {
  public init()
  public func invoke(payment: [Swift.String : Any], result: @escaping (KNBusinessModule.KNMakePayment?) -> Swift.Void)
}
public struct KNPaymentSettingsUseCase {
  public init()
  public func invoke(result: @escaping (KNBusinessModule.KNPaymentSettings?) -> Swift.Void)
}
public struct KNSendOperationEmailUseCase {
  public init()
  public func invoke(email: Swift.String, operationId: Swift.String, result: @escaping (KNBusinessModule.KNSendRecipe?) -> Swift.Void)
}
public typealias KNOperations = (response: [KNCore.KNOperation]?, error: Swift.Error?)
public struct KNOperationsResult : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNMovementCard : Swift.Codable {
  public let number: Swift.String?
  public let expirationMonth: Swift.String?
  public let expirationYear: Swift.String?
  public let track2: Swift.String?
  public let type: Swift.String?
  public let name: Swift.String?
  public let msr1: Swift.String?
  public let msr2: Swift.String?
  public let msr3: Swift.String?
  public let emvFlag: Swift.String?
  public let msrFlag: Swift.String?
  public let emvData: Swift.String?
  public let cvv: Swift.String?
  public let zipcode: Swift.String?
  public let months: Swift.String?
  public let interests: Swift.String?
  public let tCharacter: Swift.String?
  public let startCardNumber: Swift.String?
  public let endCardNumber: Swift.String?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct KNOTAConfigUseCase {
  public init()
  public func invoke(deviceType: KNCore.KNConnectionReaderType, result: @escaping (KNBusinessModule.KNOTAConfig?) -> Swift.Void)
}
public typealias KNAuth = (response: KNBusinessModule.KNTokenInfo?, error: Swift.Error?)
public struct KNAuthDomain : Swift.Codable {
  public let success: Swift.Bool
  public let connection: KNBusinessModule.KNTokenInfo?
  public let error: KNBusinessModule.KNAuthError?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNTokenInfo : Swift.Codable {
  public let expires: Swift.String
  public let token: Swift.String
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNAuthError : Swift.Codable {
  public let code: Swift.String
  public let message: Swift.String
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public typealias KNAuthInfo = (response: KNBusinessModule.KNUserInfo?, connection: KNBusinessModule.KNTokenInfo?, error: Swift.Error?)
public struct KNUserInfo : Swift.Codable {
  public let fullProfile: Swift.Bool
  public let verifiedEmail: Swift.Bool
  public let verifiedPhone: Swift.Bool
  public let fullname: Swift.String
  public let email: Swift.String
  public let phone: Swift.String
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNResponseError : Swift.Codable {
  public let code: Swift.Int
  public let message: Swift.String
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public typealias KNReversal = (response: Swift.String?, error: KNBusinessModule.KNBackendError?)
public struct KNReversalDomain : Swift.Codable {
  public let success: Swift.Bool
  public let result: KNBusinessModule.KNReversalResult?
  public let message: Swift.String?
  public let error: KNBusinessModule.KNBackendError?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNReversalResult : Swift.Codable {
  public let token: Swift.String
  public let status: Swift.Bool
  public let method: Swift.String
  public let card: Swift.String?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNBackendError : Swift.Codable {
  public let code: Swift.String?
  public let message: Swift.String?
  public let description: Swift.String?
  public let httpCode: Swift.Int?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNUserLoginUseCase {
  public init()
  public func invoke(user: Swift.String, password: Swift.String, result: @escaping (KNBusinessModule.KNAuthInfo?) -> Swift.Void)
}
public typealias KNPartialPromotion = (response: KNBusinessModule.KNPromotionResult?, error: Swift.Error?)
public struct KNPromotionResult : Swift.Codable {
  public let binInfo: KNBusinessModule.KNBinInfo?
  public let cash: KNBusinessModule.KNCash
  public let promotions: [KNBusinessModule.KNPromotion]?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNPromotion : Swift.Codable {
  public let months: Swift.Int
  public let amount: Swift.String
  public let promotionId: Swift.Int
  public let rate: Swift.Float
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNBinInfo : Swift.Codable {
  public let bankName: Swift.String
  public let cardBrand: Swift.String
  public let cardType: Swift.String
  public let countryCode: Swift.String
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNCash : Swift.Codable {
  public let detail: Swift.String
  public let variable: Swift.Float
  public let type: Swift.String
  public init(from decoder: Swift.Decoder) throws
  public init(detail: Swift.String, variable: Swift.Float, type: Swift.String)
  public func encode(to encoder: Swift.Encoder) throws
}
public typealias KNOTAConfig = (response: KNBusinessModule.KNOTAConfigResult?, error: Swift.Error?)
public struct KNOTAConfigResult : Swift.Codable {
  public let device: Swift.String
  public let active: Swift.Bool
  public let lastFirmwareVersion: Swift.String?
  public let lastConfigVersion: Swift.String?
  public let firmwareDownloadUrl: Swift.String?
  public let configDownloadUrl: Swift.String?
  public let contactless: Swift.Bool
  public let forceUpdate: Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNRecipeUseCase {
  public init()
  public func invoke(operationId: Swift.String, result: @escaping (KNBusinessModule.KNRecipeRes?) -> Swift.Void)
}
public enum KNNetworkMethods : Swift.String {
  case get
  case post
  case put
  case patch
  case delete
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct KNNetworkRequest {
}
extension Swift.String : Swift.Error {
  public var errorDescription: Swift.String {
    get
  }
}
public struct KNOperationsUseCase {
  public init()
  public func invoke(offset: Swift.Int, limit: Swift.Int, result: @escaping (KNBusinessModule.KNOperations?) -> Swift.Void)
}
public typealias KNRecipeRes = (response: KNBusinessModule.KNRecipeResponse?, error: Swift.Error?)
public struct KNRecipeResponse : Swift.Codable {
  public let success: Swift.Bool
  public let result: KNBusinessModule.KNRecipeResult?
  public let message: Swift.String?
  public let error: KNBusinessModule.KNAuthError?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNRecipeResult : Swift.Codable {
  public let user: Swift.String
  public let transaction: Swift.String
  public let timestamp: Swift.String
  public let receipt: KNBusinessModule.Receipt
  public let card: KNBusinessModule.Card?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@objc public class Receipt : ObjectiveC.NSObject, Swift.Codable {
  final public let businessName: Swift.String
  final public let webpage: Swift.String?
  final public let facebook: Swift.String?
  final public let twitter: Swift.String?
  final public let extra: Swift.String?
  final public let phone: KNBusinessModule.ReceiptPhone?
  final public let address: KNBusinessModule.ReceiptAddress?
  public var isOriginalTicket: Swift.Bool?
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
@objc public class Card : ObjectiveC.NSObject, Swift.Codable {
  final public let credit: Swift.Bool?
  final public let label: Swift.String?
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
@objc public class ReceiptPhone : ObjectiveC.NSObject, Swift.Codable {
  final public let label: Swift.String?
  final public let number: Swift.String?
  final public let ext: Swift.String?
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
@objc public class ReceiptAddress : ObjectiveC.NSObject, Swift.Codable {
  final public let street: Swift.String?
  final public let numberExt: Swift.String?
  final public let numberInt: Swift.String?
  final public let town: Swift.String?
  final public let zipCode: Swift.String?
  final public let city: Swift.String?
  final public let country: Swift.String?
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
public typealias KNSendRecipe = (response: Swift.Bool?, error: Swift.Error?)
public struct KNSendRecipeDomain : Swift.Codable {
  public let success: Swift.Bool
  public let message: Swift.String?
  public let error: KNBusinessModule.KNAuthError?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public typealias KNSign = (response: Swift.Bool, error: Swift.Error?)
public struct KNSignDomain : Swift.Codable {
  public let success: Swift.Bool
  public let result: KNBusinessModule.KNSignResult?
  public let message: Swift.String?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNSignResult : Swift.Codable {
  public let success: Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KNUploadSignUseCase {
  public init()
  public func invoke(body: [Swift.String : Any], result: @escaping (KNBusinessModule.KNSign?) -> Swift.Void)
}
public class KNThreadDispatcher {
  final public let queue: Dispatch.DispatchQueue
  public init(queue: Dispatch.DispatchQueue)
  @objc deinit
}
@_inheritsConvenienceInitializers public class KNQueueAsync : KNBusinessModule.KNThreadDispatcher {
  public func dispatch(_ work: @escaping () -> Swift.Void)
  public func dispatch(_ workItem: Dispatch.DispatchWorkItem)
  public func dispatch(label: Swift.String) -> KNBusinessModule.KNThreadDispatcher
  override public init(queue: Dispatch.DispatchQueue)
  @objc deinit
}
@_inheritsConvenienceInitializers public class KNQueueSync : KNBusinessModule.KNThreadDispatcher {
  public func dispatch(_ work: @escaping () -> Swift.Void)
  public func dispatch(_ workItem: Dispatch.DispatchWorkItem)
  public func dispatch(label: Swift.String) -> KNBusinessModule.KNThreadDispatcher
  override public init(queue: Dispatch.DispatchQueue)
  @objc deinit
}
extension KNBusinessModule.KNNetworkError : Swift.Equatable {}
extension KNBusinessModule.KNNetworkError : Swift.Hashable {}
extension KNBusinessModule.KNNetworkError : Swift.RawRepresentable {}
@available(*, unavailable, renamed: "Connection")
extension KNBusinessModule.Reachability.NetworkStatus : Swift.Equatable {}
@available(*, unavailable, renamed: "Connection")
extension KNBusinessModule.Reachability.NetworkStatus : Swift.Hashable {}
extension KNBusinessModule.Reachability.Connection : Swift.Equatable {}
extension KNBusinessModule.Reachability.Connection : Swift.Hashable {}
extension KNBusinessModule.KNNetworkMethods : Swift.Equatable {}
extension KNBusinessModule.KNNetworkMethods : Swift.Hashable {}
extension KNBusinessModule.KNNetworkMethods : Swift.RawRepresentable {}
